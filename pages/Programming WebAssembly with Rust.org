* Introduction
:PROPERTIES:
:collapsed: true
:END:
** with webassembly there is a symbiotic relationship between the compiled WebAssembly binary(called a module) and the host responsible for interpreting it
*** this relationship is at the heart of everything that you can do with this new technology and understanding where the boundaries are between module and host is key to being able to build effective WebAssembly applications.
** WebAssembly can be view at two different levels - the raw, foundational level and at the higher level of other programming languages using WebAssembly as a target
** you could write loosely coupled business logic that flows between servers, services, clients and browsers
** WASM is designed to be portable | WebAssembly is a portable binary instruction format
** This is very similar to the original intent behind Java's bytecode and the .NET framework
* Understanding WebAssembly Architecture
:PROPERTIES:
:collapsed: true
:END:
** it's unique architecture makes it incredibly powerful, portable and efficient
** Stack Machines
*** Laptops, desktops, mobile devices, virtual machines, even microcontrollers and embedded devices are register machines
*** WebAssembly is a stack machine
**** i.e, most of the instructions assume that the operands are sitting on the stack, rather than stored in specified registers
*** the WebAssembly stack is a LIFO stack
*** there are a number of advantages to a stack machine that made it appealing choice for WebAssembly: their small binary size, efficient instruction coding and ease of portability
*** JVM and the bytecode executor for the .NEW Common Language Runtime are other fairly well-known stack machines
* Data Types
** Assembly languages are made up of primitives that can be used as building blocks by higher level languages
* Control Flow
** WASM control flow is accomplished the same way everything else is within a stack machine - by pushing things onto, and popping things off of, the stack
** example of an if statement
*** #+BEGIN_SRC 
:PROPERTIES:
:collapsed: true
:END:
(if (i32.eq (call $getHealth) (i32.const 0))
      (then (call $doDeath)) 
      (else  (call $stillAlive))
)
*** #+END_SRC
*** avaliable control flow instructions in WebAssembly
**** if
**** else
**** loop
**** block
**** br
**** br\_if - identical
**** br\_table
****
* Linear Memory